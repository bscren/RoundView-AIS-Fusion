# 性能优化测试指南

## ✅ 已应用的优化

### 优化1: JPEG质量从90降到75
- **预期效果**: 编码时间减少 30-40%
- **图像质量影响**: 非常小（人眼几乎无法察觉）
- **实施状态**: ✅ 已完成并构建

## 🧪 测试步骤

### Step 1: 运行优化后的节点

```bash
cd /home/tl/RV
source install/setup.bash

# 运行节点并保存日志
ros2 run image_stitching_pkg JH_ROS_stitch 2>&1 | tee perf_test_optimized.log
```

### Step 2: 观察性能日志

**正常帧（应该更稳定）**：
```
[INFO] PSG处理耗时: 55 毫秒
⚠️ [节点层性能] 总耗时: 59 ms
  步骤A-获取轨迹锁: 0 ms | 步骤B-拼接处理: 41 ms | 
  步骤C-获取轨迹框: 0 ms | 步骤D-获取GNSS锁: 0 ms | 
  步骤E-发布图像: 18 ms     ← 应该保持在15-20ms
```

**慢帧（应该显著改善）**：
```
[INFO] PSG处理耗时: 85 毫秒  ← 期望从原来的168ms降到80-100ms
⚠️ [节点层性能] 总耗时: 85 ms
  步骤A-获取轨迹锁: 0 ms | 步骤B-拼接处理: 41 ms | 
  步骤C-获取轨迹框: 0 ms | 步骤D-获取GNSS锁: 0 ms | 
  步骤E-发布图像: 44 ms     ← 期望从原来的127ms降到40-60ms

📤 [发布性能详细] 总耗时: 44ms  ← 自动输出详细分解
  发布步骤1-图像转换: 2ms
  发布步骤2-构建头: 0ms
  发布步骤3-JSON: 1ms
  发布步骤4-JPEG编码: 35ms   ← 期望从原来的98ms降到30-50ms
  发布步骤5-ROS发布: 6ms
```

### Step 3: 对比优化前后的数据

| 指标 | 优化前 | 优化后（目标） | 改善幅度 |
|------|--------|---------------|---------|
| **正常帧耗时** | 55-65ms | 50-60ms | 5-10% |
| **慢帧耗时** | 160-180ms | 80-100ms | **40-50%** |
| **发布步骤E** | 18/127ms | 15/40-60ms | **50-60%** |
| **JPEG编码** | 10-15/98ms | 8-12/30-50ms | **40-50%** |
| **波动倍数** | 3x | 1.5-2x | **减半** |

### Step 4: 收集关键指标

运行2-3分钟后，在日志中搜索：

```bash
# 查看所有慢帧（>100ms）
grep "⚠️ \[节点层性能\]" perf_test_optimized.log

# 统计发布步骤耗时分布
grep "发布步骤4-JPEG编码" perf_test_optimized.log | \
  awk -F': ' '{print $2}' | awk '{print $1}' | \
  awk '{sum+=$1; sumsq+=$1*$1; count++} 
       END {print "平均:", sum/count "ms", 
            "标准差:", sqrt(sumsq/count - (sum/count)^2) "ms"}'

# 查看JPEG编码的异常情况
grep "⚠️ JPEG编码耗时异常" perf_test_optimized.log
```

## 📊 预期结果

### 最佳情况（JPEG编码是主要瓶颈）

**优化效果**：
- 慢帧耗时从 168ms → 85ms（减少 **50%**）
- 发布步骤从 127ms → 44ms（减少 **65%**）
- JPEG编码从 98ms → 35ms（减少 **64%**）

### 中等情况（JPEG编码和ROS发布都有问题）

**优化效果**：
- 慢帧耗时从 168ms → 110ms（减少 **35%**）
- 发布步骤从 127ms → 65ms（减少 **49%**）
- JPEG编码从 98ms → 45ms（减少 **54%**）
- ROS发布仍有 20-30ms 的波动

### 最差情况（ROS发布是主要瓶颈）

**优化效果**：
- 慢帧耗时从 168ms → 140ms（减少 **17%**）
- JPEG编码改善明显，但ROS发布仍需30-50ms

**下一步优化**：需要优化ROS2 QoS设置

## 🎯 后续优化方案

### 如果效果显著（减少>40%）

✅ **成功！** JPEG编码确实是主要瓶颈，当前优化已足够。

可选的进一步优化：
- 如果仍需更快，可继续降低质量到 70 或 65
- 考虑改用WebP格式（更快且文件更小）

### 如果效果有限（减少<25%）

需要优化ROS2发布步骤。修改发布者的QoS设置：

```cpp
// 在 src/image_stitching_pkg/src/JH_ros2_stitch_node.cpp
// 找到 stitched_pub_ 的创建位置（约第270行）

// 原始代码：
stitched_pub_ = this->create_publisher<JHjpgMsg>(config.jhjpg_msg_topic, 10);

// 修改为：
auto pub_qos = rclcpp::QoS(rclcpp::KeepLast(1))
    .reliability(rclcpp::ReliabilityPolicy::BestEffort)  // 不保证可靠性
    .durability(rclcpp::DurabilityPolicy::Volatile);     // 不持久化

stitched_pub_ = this->create_publisher<JHjpgMsg>(config.jhjpg_msg_topic, pub_qos);
```

### 如果ROS发布仍然很慢（>30ms）

考虑更高级的优化：

**选项1：使用更快的DDS实现**
```bash
# 安装 FastDDS（通常比 CycloneDDS 更快处理大消息）
sudo apt install ros-humble-rmw-fastrtps-cpp

# 使用 FastDDS
export RMW_IMPLEMENTATION=rmw_fastrtps_cpp
ros2 run image_stitching_pkg JH_ROS_stitch
```

**选项2：使用共享内存传输**
```bash
# FastDDS 的共享内存传输（零拷贝，极快）
export RMW_IMPLEMENTATION=rmw_fastrtps_cpp
export FASTRTPS_DEFAULT_PROFILES_FILE=/path/to/fastdds_shm.xml
```

`fastdds_shm.xml`:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<profiles>
    <transport_descriptors>
        <transport_descriptor>
            <transport_id>SHMTransport</transport_id>
            <type>SHM</type>
        </transport_descriptor>
    </transport_descriptors>
</profiles>
```

**选项3：异步编码（复杂但彻底）**

在独立线程中进行JPEG编码，主线程不等待编码完成即可继续处理下一帧。

## 📈 性能指标记录表

| 时间点 | 正常帧(ms) | 慢帧(ms) | 发布步骤E(ms) | JPEG编码(ms) | ROS发布(ms) | 备注 |
|--------|-----------|---------|--------------|-------------|------------|------|
| **优化前** | 55-65 | 160-180 | 18 / 127 | 10-15 / 98 | 1-3 / 26 | 基线 |
| **JPEG质量75** | ? | ? | ? | ? | ? | 填写实测值 |
| **QoS优化** | ? | ? | ? | ? | ? | 如需要 |

## 🔍 故障排查

### 问题1：优化后没有明显改善

**可能原因**：
1. ROS发布是主要瓶颈（不是JPEG编码）
2. 拼接器的步骤2（图像扭曲）才是真正瓶颈

**排查方法**：
```bash
# 查看拼接器层面的详细耗时（在慢帧时自动输出）
grep "⚠️ \[性能分析\]" perf_test_optimized.log

# 如果看到 "步骤2-图像扭曲: XXXms" 超过100ms
# 说明GPU warping才是真正瓶颈（参见之前的GPU分析）
```

### 问题2：图像质量明显下降

JPEG质量75应该非常接近90的效果。如果确实需要更高质量：

```cpp
// 折中方案：质量82（仍能减少20%编码时间）
params.push_back(82);
```

### 问题3：某些帧突然特别慢（>200ms）

查看是否有其他系统负载：
```bash
# 监控CPU
htop

# 检查是否有其他进程争抢资源
ps aux --sort=-%cpu | head -10
```

## ✅ 验证清单

运行测试后，确认以下指标：

- [ ] 正常帧耗时稳定在 50-60ms
- [ ] 慢帧耗时降低到 80-100ms（从原来的160-180ms）
- [ ] 发布步骤E的慢帧耗时 < 60ms（从原来的127ms）
- [ ] JPEG编码的慢帧耗时 < 50ms（从原来的98ms）
- [ ] 波动倍数从 3倍 降低到 2倍以内
- [ ] 图像质量在接收端检查无明显劣化

## 📞 需要帮助？

如果测试后效果不理想，请提供：

1. **日志片段**：包含几个慢帧的详细性能分解
2. **关键数值**：
   - 优化后的慢帧总耗时
   - 发布步骤4（JPEG编码）的耗时
   - 发布步骤5（ROS发布）的耗时
3. **环境信息**：
   - CPU型号和核心数：`lscpu | grep "Model name"`
   - 内存大小：`free -h`
   - ROS2 DDS实现：`echo $RMW_IMPLEMENTATION`

基于这些信息，我可以提供更精确的优化建议！

---

**创建日期**: 2025-12-12  
**优化版本**: JPEG质量 90→75  
**预期改善**: 慢帧耗时减少 40-50%

