# publishStitchedImage 性能波动深度分析

## 📊 问题现象

`publishStitchedImage` 函数耗时从 **18ms 波动到 127ms**（波动超过7倍！），是整体性能波动的主要原因。

```
正常情况: 步骤E-发布图像: 18 ms  (占总耗时 59ms 的 30%)
异常情况: 步骤E-发布图像: 127 ms (占总耗时 168ms 的 75%)
```

## 🔍 发布函数的5个步骤

```cpp
步骤1: 图像类型转换 (CV_16SC3/CV_32FC3 → CV_8UC3)
步骤2: 构建消息头 (timestamp, id)
步骤3: 构建JSON消息 (轨迹框 + GNSS)
步骤4: JPEG编码 ⭐⭐⭐⭐⭐ (最可能的瓶颈)
步骤5: ROS2发布 ⭐⭐⭐⭐ (次要瓶颈)
```

## 🎯 最可能的性能波动原因

### 原因1: JPEG编码的CPU波动 ⭐⭐⭐⭐⭐ (极高可能性)

**问题描述**：
- `cv::imencode(".jpg", ...)` 是CPU密集型操作
- 质量参数设置为90（较高质量 = 更长编码时间）
- 编码时间与图像内容复杂度高度相关

**触发条件**：
```cpp
// 场景1：图像内容简单（海面平静、云层均匀）
编码时间: 10-15ms ✅

// 场景2：图像内容复杂（波浪密集、船只多、纹理丰富）
编码时间: 80-120ms ❌
```

**验证方法**：
运行节点后，观察日志中的：
```
📤 [发布性能详细] 总耗时: XXXms
  发布步骤4-JPEG编码: XXXms  ← 关注这个数值！
```

如果步骤4的耗时占发布总耗时的70%以上，说明这是主要瓶颈。

**解决方案**：

**方案A：降低JPEG质量（快速见效）**
```cpp
// 在 publishStitchedImage 中修改
params.push_back(cv::IMWRITE_JPEG_QUALITY);
params.push_back(70);  // 从90降到70，可以减少30-50%编码时间
```

**方案B：使用多线程JPEG编码**
```cpp
// 使用libjpeg-turbo的并行编码（如果OpenCV支持）
params.push_back(cv::IMWRITE_JPEG_OPTIMIZE);
params.push_back(1);
```

**方案C：改用更快的编码格式**
```cpp
// PNG编码（通常更快，但文件更大）
cv::imencode(".png", stitched_8u, jh_msg.picture, 
    {cv::IMWRITE_PNG_COMPRESSION, 3});  // 0-9，3是快速压缩

// WebP编码（更快且文件更小）
cv::imencode(".webp", stitched_8u, jh_msg.picture, 
    {cv::IMWRITE_WEBP_QUALITY, 80});
```

**方案D：预编码缓存（复杂但高效）**
```cpp
// 在独立线程中异步编码，主线程直接发送缓存的结果
std::thread encoding_thread_;
std::queue<cv::Mat> encoding_queue_;
std::queue<std::vector<uchar>> encoded_results_;
```

### 原因2: ROS2 DDS序列化与网络I/O ⭐⭐⭐⭐ (高可能性)

**问题描述**：
- ROS2使用DDS中间件（默认CycloneDDS或FastDDS）
- 大消息（JPEG图像可能几百KB）的序列化和发送有开销
- DDS可能有：
  - 内部缓冲区管理
  - 分片传输（大消息分成多个小包）
  - QoS策略的影响（可靠性、历史深度等）

**触发条件**：
```
正常情况: DDS缓冲区充足，网络空闲
           → 发布耗时: 1-3ms ✅

异常情况: DDS缓冲区繁忙，网络拥塞，或接收端处理慢
           → 发布耗时: 30-50ms ❌
```

**验证方法**：
观察日志中的：
```
📤 [发布性能详细] 总耗时: XXXms
  发布步骤5-ROS发布: XXXms  ← 关注这个数值！
  
⚠️ ROS2发布耗时异常: XXms (消息总大小:XXX bytes)
```

**解决方案**：

**方案A：优化QoS策略**
```cpp
// 在创建发布者时使用更宽松的QoS
auto qos = rclcpp::QoS(rclcpp::KeepLast(1))  // 只保留最新1条
    .reliability(rclcpp::ReliabilityPolicy::BestEffort)  // 不保证可靠性
    .durability(rclcpp::DurabilityPolicy::Volatile);     // 不持久化

stitched_pub_ = this->create_publisher<JHjpgMsg>(
    config.jhjpg_msg_topic, qos);
```

**方案B：增大DDS传输单元（避免分片）**
```bash
# 修改 ROS2 DDS配置
export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp
export CYCLONEDDS_URI="file:///path/to/cyclonedds.xml"
```

`cyclonedds.xml` 内容：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<CycloneDDS>
  <Domain>
    <Internal>
      <FragmentSize>65000</FragmentSize>  <!-- 增大分片大小 -->
    </Internal>
  </Domain>
</CycloneDDS>
```

**方案C：使用零拷贝传输（高级）**
```cpp
// 使用ROS2的Loaned Messages（如果DDS支持）
auto loaned_msg = stitched_pub_->borrow_loaned_message();
// ... 填充消息
stitched_pub_->publish(std::move(loaned_msg));
```

### 原因3: 图像类型转换（normalize/convertTo） ⭐⭐ (低可能性)

**问题描述**：
步骤1的normalize和convertTo操作可能有波动。

**验证方法**：
观察日志中的：
```
发布步骤1-图像转换: XXXms
```

如果这个值经常超过5ms，可能有问题。

**解决方案**：
```cpp
// 使用查找表（LUT）加速normalize
static cv::Mat lut;
if (lut.empty()) {
    lut = cv::Mat(1, 256, CV_8U);
    for (int i = 0; i < 256; i++) {
        lut.at<uchar>(i) = cv::saturate_cast<uchar>(i);
    }
}
```

### 原因4: JSON序列化耗时波动 ⭐ (极低可能性)

轨迹框数量变化会影响JSON构建时间，但通常只有几毫秒。

**验证方法**：
观察日志中的：
```
发布步骤3-JSON: XXXms
```

如果超过10ms，说明轨迹框特别多（>100个）。

## 📈 诊断流程

### Step 1: 运行节点并收集日志

```bash
cd /home/tl/RV
source install/setup.bash
ros2 run image_stitching_pkg JH_ROS_stitch 2>&1 | tee publish_perf.log
```

### Step 2: 等待性能波动出现

当看到 `⚠️ [节点层性能] 总耗时: XXX ms` 且步骤E耗时>50ms时，会自动输出：

```
📤 [发布性能详细] 总耗时: 127ms
  发布步骤1-图像转换: 2ms
  发布步骤2-构建头: 0ms
  发布步骤3-JSON: 1ms
  发布步骤4-JPEG编码: 98ms   ← 如果这里最高，说明是JPEG编码问题
  发布步骤5-ROS发布: 26ms     ← 如果这里次高，说明DDS也有问题
```

### Step 3: 分析瓶颈并应用对策

| 瓶颈步骤 | 耗时特征 | 主要原因 | 快速修复 |
|---------|---------|---------|---------|
| **步骤4-JPEG编码** | >80ms | 图像内容复杂 | 降低质量到70 |
| **步骤5-ROS发布** | >30ms | DDS缓冲/网络 | 改用BestEffort QoS |
| **步骤1-图像转换** | >5ms | 类型转换开销 | 优化转换路径 |

### Step 4: 对比测试

**测试1：降低JPEG质量**
```cpp
params.push_back(90);  // 原始
↓
params.push_back(70);  // 测试

预期效果: 编码时间减少 30-50%
```

**测试2：改用BestEffort QoS**
```cpp
// 在 JH_ros2_stitch_node.cpp 的 stitched_pub_ 创建处
rclcpp::QoS(10)  // 原始
↓
rclcpp::QoS(rclcpp::KeepLast(1))
    .reliability(rclcpp::ReliabilityPolicy::BestEffort)

预期效果: ROS发布时间减少 50-70%
```

## 🚀 推荐的优化顺序

### 第一步：快速验证（5分钟）

修改JPEG质量为70，重新编译运行：

```cpp
// src/image_stitching_pkg/src/JH_ros2_stitch_node.cpp
params.push_back(cv::IMWRITE_JPEG_QUALITY);
params.push_back(70);  // 从90改为70
```

```bash
cd /home/tl/RV
colcon build --packages-select image_stitching_pkg
source install/setup.bash
ros2 run image_stitching_pkg JH_ROS_stitch
```

观察日志，如果步骤4的耗时显著降低（如从98ms降到50ms），说明JPEG编码就是主要瓶颈。

### 第二步：优化QoS（10分钟）

如果步骤5的耗时也很高（>30ms），添加QoS优化：

```cpp
// 在 JH_ros2_stitch_node.cpp 的构造函数中
// 修改发布者创建：
auto pub_qos = rclcpp::QoS(rclcpp::KeepLast(1))
    .reliability(rclcpp::ReliabilityPolicy::BestEffort)
    .durability(rclcpp::DurabilityPolicy::Volatile);

stitched_pub_ = this->create_publisher<JHjpgMsg>(
    config.jhjpg_msg_topic, pub_qos);
```

### 第三步：考虑异步编码（高级）

如果仍不满意，实现异步JPEG编码：

```cpp
// 在类中添加成员
std::thread encoding_thread_;
std::atomic<bool> encoding_running_{false};
std::queue<cv::Mat> encoding_queue_;
std::mutex encoding_mutex_;

// 在后台线程中编码
void encodingThreadFunc() {
    while (encoding_running_) {
        cv::Mat img;
        {
            std::lock_guard<std::mutex> lock(encoding_mutex_);
            if (encoding_queue_.empty()) {
                std::this_thread::sleep_for(std::chrono::milliseconds(1));
                continue;
            }
            img = encoding_queue_.front();
            encoding_queue_.pop();
        }
        
        std::vector<uchar> jpeg_data;
        cv::imencode(".jpg", img, jpeg_data, {cv::IMWRITE_JPEG_QUALITY, 70});
        // ... 发布编码结果
    }
}
```

## 🎯 预期优化效果

| 优化措施 | 预期减少耗时 | 实施难度 | 副作用 |
|---------|------------|---------|-------|
| JPEG质量90→70 | 30-50ms | 低 | 图像质量略降（通常可接受） |
| BestEffort QoS | 10-20ms | 低 | 可能丢帧（局域网通常无影响） |
| 异步编码 | 使主线程完全解耦 | 高 | 增加代码复杂度 |

**最优情况**：
- 原始: 18ms (正常) / 127ms (慢帧)
- 优化后: 12ms (正常) / 40ms (慢帧)
- **波动幅度从 7倍 降低到 3倍**

## 📝 监控指标说明

```
📤 [发布性能详细] 总耗时: 127ms
  ├─ 发布步骤1-图像转换: 2ms     (正常<5ms)
  ├─ 发布步骤2-构建头: 0ms       (正常<1ms)
  ├─ 发布步骤3-JSON: 1ms         (正常<5ms, 轨迹框多时>10ms)
  ├─ 发布步骤4-JPEG编码: 98ms    ⚠️ 主要瓶颈！正常10-20ms，异常>80ms
  └─ 发布步骤5-ROS发布: 26ms     ⚠️ 次要瓶颈！正常1-5ms，异常>30ms

额外详细信息（当异常时自动输出）：
⚠️ JPEG编码耗时异常: 98ms (图像尺寸:1518x367, 像素数:557406, 
                           压缩后大小:124576 bytes, 压缩率:7.45%)
⚠️ ROS2发布耗时异常: 26ms (消息总大小:125000 bytes, JPEG:124576 bytes, JSON:424 bytes)
```

## 🔬 深入调查工具

### 查看DDS统计信息

```bash
# 监控话题带宽
ros2 topic bw /image_topic_all

# 监控话题频率
ros2 topic hz /image_topic_all

# 查看话题详细信息
ros2 topic info /image_topic_all -v
```

### 监控系统资源

```bash
# CPU使用率（关注JPEG编码时的CPU峰值）
htop -p $(pgrep JH_ROS_stitch)

# 内存使用（查看是否有内存瓶颈）
watch -n 1 'free -h'

# I/O等待（查看是否有磁盘瓶颈）
iostat -x 1
```

---

**更新日期**: 2025-12-12  
**版本**: 1.0  
**下一步**: 运行测试，收集步骤4和步骤5的详细耗时数据

